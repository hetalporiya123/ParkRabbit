# Topic: 1. **Event-driven notification system** â€“ Services communicate via RabbitMQ/NATS/Kafka to send notifications based on user actions.
# ğŸš— Parking Management System (Event-Driven Architecture)

A production-style **event-driven parking management system** built using **Spring Boot**, **React**, **RabbitMQ**, **PostgreSQL**, and **Docker**.

This project demonstrates how backend services communicate **asynchronously** using a message broker to generate and manage notifications without direct frontend involvement.

---

## ğŸ“Œ Project Goal

The primary goal of this project is to demonstrate:

> **An event-driven notification management system where backend services communicate via RabbitMQ.**

The system focuses on **backend-driven workflows**, scheduled jobs, and message-based communication, while keeping the frontend lightweight and simple.


---

## ğŸ§  Core Concepts Demonstrated

- Event-Driven Architecture
- Publishâ€“Subscribe pattern (RabbitMQ)
- Backend-triggered notifications
- Decoupled services
- Scheduler / cron-based events
- Containerized deployment (Docker)

---

## ğŸš€ Getting Started â€” Running ParkRabbit Locally

Follow the steps below to build and run the entire ParkRabbit system using Docker.

---

### âœ… Prerequisites

Make sure the following are installed on your system:

- Git
- Docker & Docker Compose
- Java 17+ (required only for building the backend JAR)
- Maven Wrapper (included in the repository)

---

## ğŸ§± Step 0 â€” Clone the Repository
```text
gut clone <remote repo https link>
```
## âš™ï¸ Step 1 â€” Build the Backend JAR
- Navigate to the backend directory and build the Spring Boot application.
- This step generates a JAR file that will be used by Docker to build the backend container.
```text
cd backend
./mvnw clean package -DskipTests
```
### Output JAR will be created inside:
```text
backend/target/
```
## ğŸ³ Step 2 â€” Start the Full System with Docker Compose
- Go back to the root directory and start all services.
```text
cd ..
docker compose up --build
```
### This will start:

- Spring Boot backend
- React frontend (served via Nginx)
- PostgreSQL database
- RabbitMQ message broker

## Access the Application
### Once all containers are running:

- Frontend: http://localhost:3000
- Backend API: http://localhost:8080
- RabbitMQ Management UI: http://localhost:15672
- (Default RabbitMQ credentials are defined in docker-compose.yml)
---

## ğŸ”§ Technology Stack

### Backend
- Java 17
- Spring Boot
- RabbitMQ
- PostgreSQL
- Spring Scheduler

### Frontend
- React (Vite)
- React Router
- Simple in-app notifications (toasts + list)

### Infrastructure
- Docker
- Docker Compose
- GitLab (mono-repo)

---

## ğŸ—ï¸ System Architecture (High Level)

## ParkRabbit â€” Event-Driven Parking & Notification System

## 1. Overview of User Workflow

This section describes how a user interacts with the **ParkRabbit** system and how backend services communicate **asynchronously** using an **event-driven architecture**.

The workflow focuses on **backend-triggered events and notifications**, where **RabbitMQ** enables communication between services without any direct coupling to the frontend.  
All notifications originate from backend services and are delivered to users via **WebSockets** after being processed asynchronously.

---

## 2. User Role

The system currently supports a **single user role**.

| Role | Description |
|------|-------------|
| User | Can register, log in, reserve parking slots, start parking sessions, and receive notifications throughout the entire parking lifecycle |



User

â†’ Sign Up / Login

â†’ Dashboard

â†’ Select Parking (Sidebar)

â†’ Select Parking Lot

â†’ Reservation Confirmed

â†’ Park Car Within Time Limit

â†’ Notification Updates


> **Important:**  
> All notifications are generated by **backend services** using **RabbitMQ events**, not by frontend logic.

---

## 4. Detailed User Workflow

### Step 1: User Registration and Login

- The user registers using valid credentials.
- After successful registration, the user logs in.
- The system authenticates the user and redirects them to the dashboard.

**Backend Actions**

- Authentication handled by **Spring Boot Security**.
- JWT token is issued and used for subsequent requests.
- User session context is established.

---

### Step 2: Dashboard Access

- After login, the user lands on the dashboard.
- A **â€œPâ€ (Parking)** icon is displayed in the sidebar.
- Clicking this icon initiates the parking reservation flow.

---

### Step 3: Parking Location Selection

When the user clicks the **Park** button, three parking locations are displayed:

- In Der Au  
- Stadtmitte  
- Hauptbahnhof  

The user selects one parking location.

---

### Step 4: Slot Availability Check (Branching Path)

Upon selecting a parking location, the system performs a **real-time slot availability check**, resulting in one of two scenarios.

---

#### Scenario A: Slot Is Available

- A free slot exists at the selected parking location.
- The system bypasses the queue and proceeds directly to reservation.

**User Experience**

- Reservation is immediately confirmed.
- Notification displayed:

  > *â€œParking reservation confirmed. Please park your car within 1 minute.â€*

**Backend Actions**

- Slot availability validated in the database.
- Reservation event is published to **RabbitMQ**.
- A **Spring Scheduler** starts a 1-minute expiration countdown.

---

#### Scenario B: Slot Is Not Available (Queueing)

- All slots at the selected parking location are occupied.
- The user is added to a waiting queue.

**User Experience**

- Notification page displays a waitlisted status.
- Notification displayed:

  > *â€œAll slots are currently full. You have been added to the queue.â€*

**Backend Actions**

- User ID is added to the **reservation queue**.
- Queue state is managed asynchronously using RabbitMQ.

---

## 5. Reservation Expiry Handling

If the user fails to park the car within **1 minute**, the reservation expires.

**User Notification**

> *â€œYour parking reservation has expired.â€*

**Backend Actions**

- Spring Scheduler triggers a timeout event.
- A **reservation-expired event** is published to RabbitMQ.
- The reserved slot is released and marked available.
- If a user is waiting in the queue, the slot is automatically reassigned.

---

## 6. Successful Parking Confirmation

If the user parks the car within the reservation window:

- The parking slot status changes to **OCCUPIED**.
- A parking session is started.
- The user receives the notification:

> *â€œYour parking session has started.â€*

**Backend Actions**

- Reservation is confirmed.
- Parking session is created in the database.
- Parking confirmation event is published to RabbitMQ.
- Notification is delivered via WebSocket.

> **Note:**  
> For testing purposes, the parking session duration is set to **2 minutes**.

---

## 7. Parking Session Expiry Handling

This step handles the transition from an active parking session to its conclusion.

### Reminder Notification

- Before the session ends, the user receives a reminder:

  > *â€œYour parking session is ending soon.â€*

### Session End Notification

- Once the 2-minute session duration expires, the system automatically ends the session.
- The user receives the final notification:

  > *â€œYour parking session has ended.â€*

**Backend Actions**

- Spring Scheduler triggers a session timeout.
- A **session-ended event** is published to RabbitMQ.
- Parking slot is freed.
- Reservation is marked as completed.
- Next queued user (if any) is auto-assigned the slot.

---

## 8. Key Highlights of the System

- No direct frontend-triggered notifications
- Fully **backend-driven notification system**
- Time-based logic implemented using **Spring Scheduler**
- **RabbitMQ** enables reliable, decoupled event communication
- Notifications are persisted in the database before delivery
- Real-time delivery handled via **WebSockets**
- Entire system is **fully containerized using Docker**

---

# ğŸ…¿ï¸ ParkRabbit â€” Monorepo Structure

This document describes the **monorepo layout** of **ParkRabbit**, a backend-heavy, event-driven parking management system built using **Spring Boot**, **RabbitMQ**, **PostgreSQL**, and **React**.

The repository is structured to clearly separate **concerns**, **runtime boundaries**, and **deployment responsibilities**, while still allowing unified versioning and local orchestration.

---

## ğŸ“¦ Repository Overview

```text
ParkRabbit/
â”œâ”€â”€ backend/                         # Spring Boot backend service
â”œâ”€â”€ frontend/                        # React frontend application
â”œâ”€â”€ docker-compose.yml               # Multi-container orchestration
â”œâ”€â”€ .env                             # Global environment variables
â”œâ”€â”€ README.md                        # Project overview & documentation
```
### The backend is designed as a layered, event-driven system with strict separation between API contracts, business logic, persistence, and asynchronous messaging.
```text
backend/
â”œâ”€â”€ .vscode/                         # IDE-specific settings
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main/
â”‚   â”‚   â”œâ”€â”€ java/
â”‚   â”‚   â”‚   â””â”€â”€ com/parkrabbit/backend/
â”‚   â”‚   â”‚       â”œâ”€â”€ config/           # Application, RabbitMQ, WebSocket, security configs
â”‚   â”‚   â”‚       â”œâ”€â”€ controller/       # REST API controllers (HTTP boundary)
â”‚   â”‚   â”‚       â”œâ”€â”€ dto/              # DTOs for API contracts & domain events
â”‚   â”‚   â”‚       â”œâ”€â”€ entity/           # JPA entities (User, Reservation, Session, Notification)
â”‚   â”‚   â”‚       â”œâ”€â”€ exception/        # Global & custom exception handling
â”‚   â”‚   â”‚       â”œâ”€â”€ mapper/           # Entity â†” DTO mapping layer
â”‚   â”‚   â”‚       â”œâ”€â”€ messaging/        # RabbitMQ producers & consumers
â”‚   â”‚   â”‚       â”œâ”€â”€ repository/       # JPA repositories (database access)
â”‚   â”‚   â”‚       â”œâ”€â”€ scheduler/        # Time-based jobs (reservation/session expiry)
â”‚   â”‚   â”‚       â”œâ”€â”€ security/         # Authentication & authorization (JWT, filters)
â”‚   â”‚   â”‚       â”œâ”€â”€ service/          # Core business logic
â”‚   â”‚   â”‚       â”œâ”€â”€ websocket/        # WebSocket handlers for real-time notifications
â”‚   â”‚   â”‚       â””â”€â”€ BackendApplication.java
â”‚   â”‚   â””â”€â”€ resources/                # application.yml, environment configs
â”‚   â””â”€â”€ test/                         # Unit & integration tests
â”œâ”€â”€ target/                           # Maven build output
â”œâ”€â”€ Dockerfile                        # Backend Docker image definition
â”œâ”€â”€ pom.xml                           # Maven dependencies & build configuration
â”œâ”€â”€ mvnw / mvnw.cmd                   # Maven wrapper
â”œâ”€â”€ .gitignore
â””â”€â”€ README.md


```
## Backend Design Principles

- Layered architecture

- Controller â†’ Service â†’ Repository â†’ Database

- DTO-based API contracts (no entity leakage)

- Asynchronous communication via RabbitMQ

- Real-time user feedback via WebSockets

- Time-driven domain logic using schedulers

- Stateless authentication with JWT

- Production-ready configuration using environment variables

## The frontend is structured to support real-time updates, clean UI composition, and clear separation between API, state, and presentation layers.

```text
frontend/
â”œâ”€â”€ node_modules/                     # Frontend dependencies
â”œâ”€â”€ public/                           # Static assets
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ api/                          # API abstraction layer (Axios services)
â”‚   â”œâ”€â”€ assets/                       # Images, animations (SVG, Lottie)
â”‚   â”œâ”€â”€ components/                  # Reusable UI components
â”‚   â”œâ”€â”€ hooks/                       # Custom hooks (WebSocket, auth, etc.)
â”‚   â”œâ”€â”€ imports/                     # Centralized imports / utilities
â”‚   â”œâ”€â”€ layouts/                     # Page layouts (Dashboard, Sidebar)
â”‚   â”œâ”€â”€ notifications/               # Notification models & state handling
â”‚   â”œâ”€â”€ routers/                     # Application routing
â”‚   â”œâ”€â”€ services/                    # Utility services (time, formatting)
â”‚   â”œâ”€â”€ index.css                    # Global styles
â”‚   â””â”€â”€ main.jsx                     # Application entry point
â”œâ”€â”€ .env                              # Frontend environment variables
â”œâ”€â”€ Dockerfile                        # Frontend Docker image definition
â”œâ”€â”€ nginx.conf                        # Nginx config for frontend container
â”œâ”€â”€ index.html
â”œâ”€â”€ package.json
â”œâ”€â”€ package-lock.json
â”œâ”€â”€ vite.config.js
â””â”€â”€ README.md
```
## Frontend Design Principles

- API abstraction layer (no direct fetch calls in UI)

- WebSocket-driven notifications

- Reusable, composable components

- Separation of layout and business logic

- Containerized production build using Nginx
---

## The project uses Docker Compose to orchestrate:

- Spring Boot backend

- React frontend (served via Nginx)

- PostgreSQL database

- RabbitMQ message broker

## This enables:

- Local development parity with production

- Clear service boundaries

- One-command startup for the entire system
  

# ===============END================

